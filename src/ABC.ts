class A {
  // ...

  // Плохая практика: метод возвращает экземпляр другого класса.
  // Это увеличивает связанность между классами A и B.
  getB() {
    return new B();
  }

  // Улучшено: вместо возврата экземпляра B, A теперь выполняет действие напрямую.
  // Это уменьшает связанность и облегчает поддержку кода.
  doSomething() {
    const b = new B();
    b.doSomething();
  }
}

class B {
  // ...

  // Плохая практика: такая же проблема
  getC() {
    return new C();
  }

  // Улучшено: тут все также
  doSomething() {
    const c = new C();
    c.doSomething();
  }
}

class C {
  // ...

  doSomething() {
    // Логика
  }
}

// Использование теперь становится проще и понятнее, без необходимости цепочки вызовов.
const a = new A();
a.doSomething();

/* Что было плохо:
1) Транзитивный доступ через a.getB().getC().doSomething() создает сильную связанность между классами A, B, и C
Это нарушает принцип Law of Demeter, усложняет тестирование и делает систему менее гибкой для изменений
2) Класс А не должен напрямую взаимодействовать с объектами В и С т.к. это нарушает инкапсуляцию
3) Каждый раз, когда меняется реализация или сигнатура методов в B или C, это влияет на весь код, который использует A, 
т.к. он явно зависит от структуры вложенных вызовов.
*/

/* Что стало лучше:
1) Слабая связанность: изменения в классах B или C минимально повлияют на A, 
т.к. взаимодействие происходит через явно определенный интерфейс
2) Упрощение использования и тестирования: теперь, чтобы вызвать метод, нужно просто обратиться к a.doSomething() а не строить цепочки 
*/